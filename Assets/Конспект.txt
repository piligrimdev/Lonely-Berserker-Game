	Здесь будут записаны мысли, возникшие при прохождении курса. За более техническими тонкостями можно обратиться к комментариям в коде

1) Lock To Target On Assign - не меняет свою ориентацию в пространстве в зависимости от ориентации объекта,
	т.е. для жесткой зафиксированной камеры это вполне пойдет
2) Лучше сделать подсветку пероснажа за стенами(тем, что мешает его видеть игроку), чем заставлять камеру перемещаться (мои мысли)
3) Для начинающего разработчика не стоит в начале разработки кропотливо заниматься тем или иным аспектом. 
   Лучшее, что он может сделать - как можно быстрее создать основу игрового цикла. Т.е. реализовать основные механики на шаблонах и готовых ассетах.
   Графика, художественное направление и детали будут готовы потоом
4) Некоторые вещи можно проверять прямо во время разработки демки - Размер стен, противников, скорость перемещения, просто играться
5) Стоит записывать свои идеи, это хорошая привычка
6) Оставляем TODO в коде!
7) Если нажать V когда перемещаешь объект, можно выбрать один из краев объекта и соеденить с краем другого объекта
8) Паттерн "наблюдатель"(своими словами) - наблюдатель может "подписаться" на объект, чтобы получать от него данные тогда, когда наблюдателю будет это интересно
   при этом объект наблюдения не должен знать о том, кто за ним наблюдает и, следовательно, не должен изменяться.
9) Кастомные окна редактора должны заниматься отрисовкой вообще всех полей SerializeField,
   т.к. не отрисованные в коде не отобразятся, даже если указаны, как SerializeFiled
10) Анализ размерности - нужен для создания формул, см. скрип RotateAround и https://en.wikipedia.org/wiki/Dimensional_analysis
11) Комментарии можно оставлять прямо на уровне в виде пометок на террейне и 3д текста
12) На ассеты можно вешать лейблы, чтобы проще было сортировать( например, для быстрого создания новой сцены)
13) То, что должно быть в каждой сцене, должн(желательно) быть ассетом и быть с лейблом
14) Камера уходила вниз при присоедининии NavMeshAgent'а к игроку из-за гравитации(?)
15) Для спусков вниз и прыжков(если будут) стоит использовать OffMeshLink
16) NavMesh создается по мешам, а не по коллайдерам
17) Поэтому можно использовать прозрачные материалы для мешей
18) FixedUpdate работает синхронизированно с физическим движком, а не покадрово, так что для перемещний используют его
19) Чтобы поменять модельку игрока, нужно убрать меш и скелет исходного, заменить его на скелет и меш нового и в аниматоре поставить аватар скелета новой модельки
20) Скейлить скелет можно прямов unity
21) https://www.youtube.com/watch?v=5UZ-niuRWz8 - как импортировать модели блендера в unity правильно
22) скейлинг моделей блендера https://www.youtube.com/watch?v=B7PztbUowdk
23) Интерфейс (interface) в C# - как виртуальный класс в C++ - нельзя создать объект, но можно от него наследоваться. 
    Класс, который наследует интерфейс, обязательно должен реализовывать все методы интерфейса. Такого рода "соглашение".
24) OnTriggerEnter вызывается у объекта, который isTrigger пересекает другой коллайдер
25) Правило "Трёх" - если что-то повторяется трижды, это следует вынести в класс, функцию/метод, переменную и.т.д.
26) “A superior pilot uses his superior judgment to avoid situations which require the use of his superior skill.”
27) Стоит сфокусироваться на одном деле до тех пор, пока успех не будет достигнут. Но стоит использовать мудрость, чтобы знать, когда поменять фокус.
28) Quaternion.identity - corresponds to "no rotation" - the object is perfectly aligned with the world or parent axes.
29) Чтобы направить что-то в сторону чего-то: вектор позиции цели - вектор позиции смотрящего
30) normalized делает вектор единичным.

